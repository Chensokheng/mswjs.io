---
title: Mocking error responses
order: 3
---

When it comes to mocking error responses, it's recommended to compose a valid response using `res` composition chain, rather than throwing an exception inside a request handler. This is mainly to distinguish between _internal_ and _intended_ exceptions.

<Hint>
  All exceptions originating from request handlers are gracefully handled as 500
  responses by the library, but it's highly recommended{' '}
  <strong>
    to resolve them, as they indicate unexpected behavior in your code
  </strong>
  .
</Hint>

By treating an error response as an actual response, and not an exception, you respect the standards and ensure your client code receives and handles a valid error response.

Let's respond to a `GET /user` request with a 403 error in case there's no `Authorization` header set:

```js highlights=3-11
rest.get('/user', (req, res, ctx) => {
  if (!req.headers.get('Authorization')) {
    return res(
      // Provide an error status code (4xx/5xx),
      ctx.status(403),
      // ...and any additional response parts,
      // such as response headers, body, etc.
      ctx.json({
        errorMessage: 'Permission denied: not authorized.',
      }),
    )
  }

  return res(
    ctx.json({
      firstName: 'John',
      lastName: 'Maverick',
    }),
  )
})
```

<ResponsePreview
  request={{
    method: 'POST',
    url: '**/login**',
    body: `
{
  "username": "admin"
}
    `,
  }}
  response={{
    statusCode: 403,
    statusText: 'Forbidden',
    body: `
{
  "errorMessage": "User 'admin' not found"
}
    `,
  }}
/>
